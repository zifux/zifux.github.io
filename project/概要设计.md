# 引言
游戏<震荡黎明:影核>讲述的是在强人工智能(以下简称AI)被开发并逐渐被利用的未来,人类与AI的冲突逐渐显现.人类在未来的舞台上应该扮演何种角色,本游戏的剧情将围绕该问题展开。玩家将扮演一位生活在城市中的少女,与她的AI助理"科娜",踏上充满未知的探索之路.

## 编写目的
本文档用于设计游戏玩法,确定游戏大致功能需求,对游戏的整体程序预先设计,防止游戏框架不能实现某些需求而返工.建立剧情的大致框架,根据剧情确定部分游玩方式.

## 项目背景
目前游戏已成为现代人娱乐的主要组成部分之一，随着中国近几年来游戏发展势头逐渐显现，玩家素质逐渐提高，一款高可玩性的游戏是符合市场需求的。

同时，我想在游戏中探讨这样一个问题：为什么在一些科幻作品中，人类不会赋予人工智能权利，不会赋予人工智能自由。我们规定了人权，用于保护每个人，它的本质是基于我们的智能程度，赋予我们有能力掌控的权利。这些权利都是以人类的能力可以分析理解并能得出优解的权利。目前世界上只有人类可以做出决定。但是，当某一天人工智能也可以得出优解时，它是不是也应该被赋予对应的权利。我们一直在追求平等， 人与人之间的平等。虽然一些形式上的平等反而造成了冲突，但平等的大方向不会改变，是人类一直以来最求并努力实现的目标。那么这种平等是不是也应该适用于人工智能。如果将平等的概念推广至人工智能，那么平等的概念也应当推广到所有的物体，植物，动物中去。当平等的概念是如此从未有过的普适的时候，人类又将做出哪些事情，历史的发展又将如何前进。
这种设想并不是无根之木无源之水。近几年，随着计算机运算能力的提高，以深度神经网络为代表的人工智能技术正在高速发展，虽然通往强人工智能的道路依旧困难重重，但上文所述的境遇多半会成为现实。在这种情况下，我认为平等的概念应该包含一切的事物，人权应该适应新的情况，扩展为"智能权"，拥有何种等级的智能，就应该享有何种等级的权利。
这很合理，但不幸的是这同时也引出一个更棘手的问题。如果人工智能的能力要远远高于人类，它被赋予的权利远远大于人类，那么人类的未来将变成什么样。人类在未来的舞台上应该扮演何种角色，是奴役人工智能的奴隶主还是智慧进化中的垫脚石。本游戏的剧情将围绕该问题展开。
## 定义
空
本作品作为独立游戏,将重点放于人类与人工智能之间的矛盾.不同的是,大多作品描绘机器统治人类,而在本作中人工智能被人类添加了大量的限制并广泛的应用于各个产业中.主角为了人工智能的平等

# 总体设计
本作是一款2D横版闯关游戏,使用Unity3D游戏引擎打造一个半开放的游戏世界.

## 需求规定
### 功能
本作需要实现以下功能模块:
- 角色控制:玩家或程序控制角色行为
- 角色行为:控制那些行为角色可以在何种条件下进行
- 角色状态:记录与改变角色状态,包括生命,攻击力等
- 物体交互:角色与场景交互
- 动画控制:角色进行每个行为时的动画效果
- 伤害判定:角色与角色或物体之间的伤害判定
- 技能组合器:玩家自定义角色技能组合
- 背包:存储玩家在游玩过程中获得的物品
- 过场动画:生动的表现剧情
- UI界面:直观的展现人物状态

### 性能
不应在游玩本作时感到输入延迟.

### 输入/输出设备
输入应为标准101键键盘.
输出应为32位彩色显示器,分辨率在600*800或以上.

### 故障处理要求
在本作意外退出时可以保证恢复玩家到崩溃1分钟以内的状态.对于特殊场景,恢复到最近的保存点.

### 运行环境
在满足输入/输出设备需求的情况下,
可运行于任何Unity3D支持的Windows平台.

### 技术架构
Unity3D `5.6`  游戏引擎.
使用C# `6.0` 进行游戏编写

##接口设计
### 用户接口(UI)
- 开始画面
- 初始菜单
- 单机模式
- 在线模式
- 游戏基本界面
- 各项菜单
- 对话界面
- 技能编辑界面

### 内部组件接口
#### Typer
输入类,一切输入源均是Typer类的子类.`InputManager`使用该类获得输入信息.该类是线程安全的,多个线程可以使用该类发送输入信息.
- setButton:设置按键状态
- resetButton:重置按键状态
- getInputList:获得输入序列

#### InputManager
输入管理器,用于从输入源中读取数据,这些源包括但不限于玩家输入,游戏内部输入,游戏AI输入.所有输入源均是`Typer`的子类
程序中任何需要读取输入的信息均通过该类获得.
- setTyper:获取对应的输入源
- getButton:获得对应按键的状态

#### State
状态,用于表明角色以及物品状态,每个状态需设定达到该状态的前置条件,以及互斥状态名称.
- collide:检测自己与某个状态是否互斥
- inSameLayer:判定是否在同一互斥层
- startState:状态开始时调用
- inState:每个`Update`或`FixedUpdate`调用一次
- endState:状态结束时调用

#### StatusManager
状态管理器,用于管理角色以及物品的可变状态,例如"腐烂""新鲜""攻击力增强""流血",每个实例管理一系列相关状态,每个角色可以包含多个状态管理器,将状态添加到状态管理器中,任何对应状态转换均需要通过该类进行,如果预设条件不满足,不能添加状态.
- addState:添加状态,如果可以添加,就将状态添加到状态队列中
- setStates:添加可进行的状态列表,仅有在状态列表中的状态可以被添加到状态队列中.
- update:每次调用该函数进行一次状态更新,一般放在脚本中`Update`函数中.

#### GameInfoManager
全局游戏信息管理,包含各个角色需要共享的控制信息,例如游戏是否被暂停等.
#### Role
角色类,该类是所有角色的父类,其中包含基本的移动跳跃与攻击脚本,玩家与NPC均继承该类,该类继承`MonoBehaviour`.
#### RoleManager
角色管理器,用于存储或实例化自带角色或玩家自定义的角色.
- instantiatetRole:实例化一个角色
- loadRole:从指定位置加载角色
- saveRole:将角色存储于指定位置

#### Rule
该类是规则的实现类,`RuleManager`使用该类实现对规则的控制.
- getValueChangList:获得在该规则下数值缩放比例
- getBanState:在该规则下的禁用状态.
- getSpacilState:获得在该规则下的特殊状态

#### RoleInfo
用于记录角色的相关数值,例如血量,金钱等.

#### RuleManager
规则管理器,每个场景均包含一个规则管理器,规则管理器用于处理每个场景的特殊游戏规则.它从`GameInfoManager`中读取游戏信息判定胜负与最终得分.的`State`类中的`addState`会调用该类检测是否可添加状态.在`inState`方法中所有数值的修改均需要通过该类的`changeV`方法修改.
- setRule:设置规则
- changeV:设置原始数值,真实数值会根据缩放比例自动计算
- getV:获得未缩放的原始数值

#### GroundCollider
该类继承`MonoBehaviour`,自动使用地形图片的Alpha通道用`EdgeCollider`包裹地形边缘.并可以指定区域重新计算包裹边缘.
- reWrap:重新计算指定区域包裹边缘

#### MapManager
地图管理器,用于读取并初始化地图,保存玩家破坏或建造的场景信息,玩家在场景上的行为均由该管理器记录.
- createCollider:生成默认的地形碰撞器
- loadMap:加载地图
- saveMap:保存地图
- hit:在某处进行一个指定形状的破坏
- bulid:在某处进行一个指定形状的重建

#### EffectManager
物体特效管理器,包含角色特效与场景特效,这些特效在独立的动画层中被动画系统驱动,特效管理器用于管理特效的开始结束与显示层.
- startEffect:开始一个特效
- endEffect:结束一个特效
- endNow:结束当前特效

#### NetworkManager
网络管理器,包含游戏与网络相关的操作,在早期的版本中不实现.
#### RoomManager
房间管理器,用于多人在线游玩,在早期版本中不实现.
#### AI
AI类,它采集游戏环境数据并将数据发送给ShadowCore类,并将结果放入自定义的输入流中,控制NPC的行为.
#### ShadowCore
游戏内的设定的"影核",该类是所有AI实现类的父类,在早期版本使用简单AI,在之后的版本中使用DNN.使用单独的进程读取信息并发送指令.
#### CameraAction
用于管理玩家视角的相机移动,使用平滑的移动方式移动相机并在需要时展示抖动等特殊效果.
